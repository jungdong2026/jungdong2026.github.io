축소 기법들

 

* 미디언 표현

이것은 화소들의 블록을 그것의 미디언 값으로 아래 그림과 같이 대치합니다. n X n 윈도우가 영상에 적용될 때, 윈도우 내의 화소들은 읽혀지면서 오름차순값으로 정렬되어집니다. 이 화소들 중에서 가운데 화소가 그 블록을 표현하는데 사용되는 것입니다.

 

아래는 미디언 표현에 의한 축소 소스코드입니다.



/***************************************************************************
 * Func: median_shrink                                                     *
 *                                                                         *
 * Desc: reduces an image using median representation                      *
 *                                                                         *
 * Params: source - pointer to image in memory                             *
 *         cols - number of columns in image                               *
 *         rows - number of rows in image                                  *
 *         filename - name of output file                                  *
 *         side - width of block                                           *
 ***************************************************************************/

void median_shrink(image_ptr source, int cols, int rows, char *filename,
		 int side)
    {
    int x, y, i;                /* image loop variables */
    int index;                  /* image index */
    FILE *fp;                   /* output file pointer */
    int *window;                /* window for block samples */
    int wsize;                  /* number of elements in block */
    unsigned char *line_buff;   /* storage for line */
    unsigned long sourcebase;   /* source base address */
    unsigned long sourceadd;    /* source address = source base + offset */
    int winx, winy;             /* x and y window indices */
    int new_rows;               /* number of rows in new image */
    int new_cols;               /* number of columns in new image */
    int new_pixel;              /* new output pixel */
    int windex;                 /* window index */



    if((fp=fopen(filename, "wb")) == NULL)
	{
	printf("Unable to open %s for output\n",filename);
	exit(1);
	}

    wsize = side * side;
    new_rows = rows/side;
    new_cols = cols/side;
    window = malloc(wsize * sizeof(int));
    line_buff = (unsigned char *) malloc(new_cols);

    fprintf(fp, "P5\n%d %d\n255\n", new_cols, new_rows); /* print out header */

    for(y=0; y< new_rows; y++)
	{
	sourcebase=((unsigned long) cols) * side * y;
	index=0;
	for(x=0; x< new_cols; x++)
	   {
	   windex=0;
	   for(winy=0; winy< side; winy++)
	       for(winx=0; winx< side; winx++)
		  {
		  sourceadd=sourcebase+winx+winy*cols;
		  window[windex++] = (int) source[sourceadd];
		  }
	   new_pixel = median(window, wsize);
	   line_buff[index++]=(unsigned char) new_pixel;
	   sourcebase+=side;
	   } /* for x */
	 fwrite(line_buff, 1, new_cols, fp);
    } /* for y */
    free(window);
    }
* 평균 표현

평균 표현도 n X n 윈도우를 사용합니다. 이 방법은 하나의 화소들의 블록을 그 블록 내의 모든 화소들의 평균으로 표현합니다. 이것은 미디언 표현만큼 느리지 않습니다.

아래는 평균 표현에 의한 축소 소스코드입니다.


/***************************************************************************
 * Func: average_shrink                                                    *
 *                                                                         *
 * Desc: Reduces an image using pixel averages                             *
 *                                                                         *
 * Params: source - pointer to image in memory                             *
 *         cols - number of columns in image                               *
 *         rows - number of rows in image                                  *
 *         filename - name of output file                                  *
 *         side - width of block                                           *
 ***************************************************************************/

void average_shrink(image_ptr source, int cols, int rows, char *filename,
		 int side)
    {
    int x, y, i;               /* image loop variables */
    int index;                 /* image index */
    FILE *fp;                  /* output file pointer */
    int *window;               /* window for block samples */
    int wsize;                 /* number of elements in block */
    unsigned char *line_buff;  /* storage for line */
    unsigned long sourcebase;  /* base address in source image */
    unsigned long sourceadd;   /* sourcebase plus a column offset */
    int winx, winy;            /* x and y indices in image window */
    int new_rows;              /* number of rows in new output image */
    int new_cols;              /* number of columns in new output image */
    int new_pixel;             /* newly generated pixel for output image */
    int windex;                /* image window index */

    if((fp=fopen(filename, "wb")) == NULL)
	{
	printf("Unable to open %s for output\n",filename);
	exit(1);
	}

    wsize = side * side;
    new_rows = rows/side;
    new_cols = cols/side;

    /* allocate memory for storage */
    window = malloc(wsize * sizeof(int));
    line_buff = (unsigned char *) malloc(new_cols);

    fprintf(fp, "P5\n%d %d\n255\n", new_cols, new_rows); /* print out header */

    for(y=0; y< new_rows; y++)
	{
	sourcebase=((unsigned long) cols) * side * y;
	index=0;
	for(x=0; x< new_cols; x++)
	   {
	   windex=0;
	   for(winy=0; winy< side; winy++)
	       for(winx=0; winx< side; winx++)
		  {
		  sourceadd=sourcebase+winx+winy*cols;
		  window[windex++] = (int) source[sourceadd];
		  }
	   new_pixel = average(window, wsize);
	   line_buff[index++]=(unsigned char) new_pixel;
	   sourcebase+=side;
	   } /* for x */
	 fwrite(line_buff, 1, new_cols, fp);
    } /* for y */
    free(window);
    }

/***************************************************************************
 * Func: average                                                           *
 *                                                                         *
 * Description: calculates the average of an array of numbers              *
 *                                                                         *
 * Params: window - array of pixel values to average                       *
 *         wsize - number of elements in the array                         *
 *                                                                         *
 * Returns: the average of the numbers in the array                        *
 ***************************************************************************/

int average(int *window, int wsize)
    {
    int i;
    unsigned sum;

    sum = 0;
    for(i=0; i< wsize; i++)
	 sum += window[i];
    return (sum/wsize);
    }
