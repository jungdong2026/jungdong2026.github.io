<p>영상의 명암대비는 밝은 화소들과 어두운 화소들의 분포에 의하여 결정됩니다. 낮은 명암대비를 가진 흑백 영상은 대부분 어둡거나, 밝거나 또는 흐리지요. 높은 명암대비를 가진 영상은 어둡고 밝은 영역을 모두 포함하고 있으며 가능한 모든 화소값의 범위를 사용합니다. 히스토그램은 상대적으로 균일한 화소값의 분포를 포함할 것이므로 특정한 마루나 골이 부각되지 않을 것입니다.</p>
<p>명암 대비 스트레칭은 영상의 명암값 분포를 최대한 활용하도록 히스토그램을 펼치기 위하여 영상에 적용하는 것입니다. 낮은 명암 대비를 가진 영상의 질을 향상시킬 수 있는 유용한 도구로서 영상이 가우시안 또는 가우시안과 유사한 분포를 가질 때 가장 잘 적용됩니다.</p>
      

      <p>2. 기본 명암 대비 스트레칭</p>
      <p>기본 명암 대비 스트레칭은 특정 부분, 즉 중앙에 명암값이 치우치는 히스토그램을 가진 영상에 가장 잘 적용됩니다. 이것은 영상 
        히스토그램이 모든 범위의 화소값을 포함하도록 영상을 확장할 것입니다. 이것은 기본 식이 있는데,</p>
      <blockquote><p>new pixel = (old pixel - low)/(high - low) X 255</p></blockquote>
      <p>입니다.</p>
      <p>영상에서 가장 낮은 값을 가진 화소값 즉, 0 을 이용하여 뺄셈 연산을 수행하면 히스토그램은 왼쪽으로 이동합니다. 이 때 각 
        화소값은 영상이 전체 명암값을 포함하도록 확장됩니다. 따라서 결과 영상은 0에서 255까지의 명암값을 가집니다.</p>
      <p>아래는 기본 명암 대비 스트레칭의 소스입니다.</p>
      <blockquote>
        <p><font color="#0066FF">#include &lt;stdio.h&gt; <br>
          #include &lt;string.h&gt; <br>
          #include &lt;malloc.h&gt; <br>
          </font></p>
        <p><font color="#0066FF">void auto_contrast_stretch(image_ptr source,char 
          fileout[], int cols, int rows, int type); <br>
          extern void write_pnm(image_ptr ptr, char filein[], int rows, int cols, 
          int magic_number ); <br>
          extern image_ptr read_pnm(char *filename, int *rows, int *cols, int 
          *type); <br>
          int main(int argc, char *argv[]){ <br>
          char filein[100]; /* name of input file */ <br>
          char fileout[100]; /* name of output file */ <br>
          int rows, cols; /* image rows and columns */ <br>
          unsigned long bytes_per_pixel; /* number of bytes per image pixel */ 
          <br>
          image_ptr source; /* pointer to image buffer */ <br>
          unsigned long number_of_pixels; /* total number of pixels in image */ 
          <br>
          int type; /* what type of image data */ </font></p>
        <p><font color="#0066FF">/* set input filename and output file name */ 
          <br>
          if(argc == 3){ <br>
          strcpy(filein, argv[1]); <br>
          strcpy(fileout, argv[2]); <br>
          }else{ <br>
          printf(&quot;Input name of input file\n&quot;); <br>
          gets(filein); <br>
          printf(&quot;\nInput name of output file\n&quot;); <br>
          gets(fileout); <br>
          printf(&quot;\n&quot;); <br>
          } </font></p>
        <p><font color="#0066FF">source = read_pnm(filein, &amp;rows, &amp;cols, 
          &amp;type); </font></p>
        <p><font color="#0066FF">/* determine bytes_per_pixel, 3 for color, 1 
          for gray-scale */ <br>
          if(type == PPM) <br>
          bytes_per_pixel = 3; <br>
          else <br>
          bytes_per_pixel = 1; </font></p>
        <p><font color="#0066FF"> number_of_pixels = bytes_per_pixel * rows * 
          cols; </font></p>
        <p><font color="#0066FF"> <b>auto_contrast_stretch( source,fileout, cols, 
          rows, type);</b> <br>
          return 0; <br>
          } </font></p>
        <p><font color="#0066FF">void auto_contrast_stretch(image_ptr source,char 
          fileout[], int cols, int rows, int type){ <br>
          long i; /* loop variable */ <br>
          long number_of_pixels; /* total number of pixels in image */ <br>
          long histogram[256]; /* image histogram */ <br>
          unsigned char LUT[256]; /* Look-up table for point process */ <br>
          int lowthresh, highthresh; /* lower and upper thresholds */ <br>
          float scale_factor; /* scaling factor for contrast stretch */ </font></p>
        <p><font color="#0066FF">/* compute histogram */ <br>
          number_of_pixels = (long)cols * rows; <br>
          for(i=0; i&lt;256; i++) histogram[i]=0; <br>
          for(i=0; i&lt;number_of_pixels; i++) histogram[source[i]]++; </font></p>
        <p><font color="#0066FF">/* compute low and high thresholds */ <br>
          for(i=0; i&lt;256; i++) <br>
          if(histogram[i]){ <br>
          lowthresh = i; <br>
          break; <br>
          } </font></p>
        <p><font color="#0066FF"> for(i=255; i&gt;0; i--) <br>
          if(histogram[i]){ <br>
          highthresh = i; <br>
          break; <br>
          } </font></p>
        <p><font color="#0066FF"> printf(&quot;Low threshold is %d High threshold 
          is %d\n&quot;,lowthresh,highthresh); </font></p>
        <p><font color="#0066FF">/* compute new LUT */ <br>
          for(i=0; i&lt;lowthresh; i++) LUT[i]=0; <br>
          for(i=255; i&gt;highthresh; i--) LUT[i]=255; <br>
          scale_factor = 255.0 / (highthresh-lowthresh); <br>
          for(i=lowthresh; i&lt;=highthresh; i++) <br>
          LUT[i]=(unsigned char)((i - lowthresh) * scale_factor); </font></p>
        <p><font color="#0066FF">/* transfer new image */ <br>
          for(i=0; i&lt;number_of_pixels; i++) source[i] = LUT[source[i]]; <br>
          write_pnm(source, fileout, rows, cols, type); <br>
          IP_FREE(source); <br>
          }</font><br>
      </p></blockquote>
      <p>&nbsp;</p>

            <p>* 히스토그램은 Matlab을 이용했습니다.</p>
      <p> source code In Matlab,</p>
      <p>fn='XXX.jpg'; //이미지화일명 삽입<br>
        c_image = imread(fn); <br>
        gray_image=rgb2gray(c_image); <br>
        imhist(gray_image);</p>
      <p>너무 간단하지요~~~<br>