영상 스케일링

영상 스케일링은 영상을 확대, 축소하는 기법입니다.

영상이나 영상의 일부분을 크게 만드는 처리는 확대(magnification), 스케일링 업(scaling up), 줌잉(zooming), 업샘플링(upsampling), 스트레칭(streching)이라 합니다.
그리고 영상을 작게 하는 것은 쉬링킹(shrinking), 스케일링 다운(scaling down), 데시메이션(decimation), 다운샘플링(downsampling), 축소(minification)이라 합니다.

스케일링에서 중요한 것은 원래의 해상도를 결코 향상시킬 수 없다는 것과 다른 한 가지는 모든 스케일링 연산들이 원래 영상을 참조해야만 한다면, 결과 영상은 어떠한 연산으로도 질이 떨어질 것입니다.

여기에선 몇가지 보간법을 이용하여 스케일링을 해보겠습니다.

 

아래 소스는 영상 스케일링의 소스입니다.

가장 인접한 이웃화소 보간법을 이용한 스케일링입니다.


#include < stdio.h> 
#include < string.h> 
#include < malloc.h> 

extern image_ptr read_pnm(char *filename, int *rows, int *cols, int *type); 
void scale_pnm(image_ptr buffer, char *fileout, int rows, int cols, float x_scale,
float y_scale, int type); 

int main(int argc, char *argv[]){ 
	char filein[100];
	char fileout[100];
	int rows, cols;
	image_ptr buffer;
	int type;
	//scale을 바꿔주는 부분
	float x_scale=0.5; 
	float y_scale=0.5; 

	if(argc == 3){ 
		strcpy(filein, argv[1]); 
		strcpy(fileout, argv[2]); 
	}else{ 
		printf("Input name of input file\n"); 
		gets(filein); 
		printf("\nInput name of output file\n"); 
		gets(fileout); 
		printf("\n"); 
	} 

	buffer = read_pnm(filein, &rows, &cols, &type); 
	scale_pnm(buffer, fileout, rows, cols, x_scale, y_scale, type); 
	IP_FREE(buffer); 
	return 0; 
} 


void scale_pnm(image_ptr buffer, char *fileout, int rows, int cols,
float x_scale, float y_scale, int type){ 
	unsigned long x,y;
	unsigned long index;
	unsigned long source_index;
	unsigned char *line_buff;
	int new_rows, new_cols; 
	unsigned line; 
	FILE *fp;
	unsigned long X_Source, Y_Source; 
	pixel_ptr color_buff;

	if((fp=fopen(fileout, "wb")) == NULL){ 
		printf("Unable to open %s for output\n",fileout); 
		exit(1); 
	} 
	new_cols = cols * x_scale; 
	new_rows = rows * y_scale; 

	fprintf(fp, "P%d\n%d %d\n255\n", type, new_cols, new_rows); 

	if(type == 5) /* PGM file */ 
		line = new_cols; 
	else /* PPM file */ 
	{ 
		line = new_cols * 3; 
		color_buff = (pixel_ptr) buffer; 
	} 

	line_buff = (unsigned char *) malloc(line); 

	for(y=0; y< new_rows; y++){ 
		index = 0; 
		for(x=0; x >new_cols; x++){ 
//원본영상의 cols가 홀수일 경우에 cealing function
//(올림을 말함)을 쓰면 안됩니다. 이 경우에는 
//ROUND function(반올림을 말함)을 권장하는데 
//그 이유는 원본이5X6사이즈인 영상을 0.5로 스케일 할
//경우에 그 에러를 확연히 발견할 수 있는데 결과 영상
//3X3중 cols의 마지막 픽셀값은 원본영상의 그 다음줄
//첫번째 픽셀값으로 대체됩니다. (예를 들면, 결과영상
//첫째줄 마지막 픽셀값(2,0)은 원본영상 셋째줄 첫번째 
//픽셀값(0,2)으로 대체됩니다. (5,1)이 없기 때문에 
//이에 대응되는 배열값은 (0,2)가 결과영상의
//픽셀값으로 대체됩니다.)
			X_Source = (unsigned long)((x / x_scale) + 0.5); 
			Y_Source = (unsigned long)((y / y_scale) + 0.5); 
			source_index = Y_Source * cols + X_Source; 
			if(type == 5) /* PGM */ 
				line_buff[index++] = buffer[source_index]; 
			else /* PPM */ 
			{ 
				line_buff[index++] = color_buff[source_index].r; 
				line_buff[index++] = color_buff[source_index].g; 
				line_buff[index++] = color_buff[source_index].b; 
			} 
		} 
	fwrite(line_buff, 1, line, fp); 
	} 
	fclose(fp); 
}
가장 인접한 이웃화소 보간법을 이용한 시뮬레이션입니다.

 

아래 소스도 영상 스케일링의 소스입니다.

이번에는 제가 과제로 짠 소스입니다. 3차 회선 보간법(cubic interpolation)을 이용한 스케일링입니다.


#include <stdio.h>
#include <string.h>
#include <malloc.h>
extern image_ptr read_pnm(char *filename, int *rows, int *cols, int *type);
void scale_pnm(image_ptr buffer, char *fileout, int rows, int cols, float x_scale, float y_scale, int type, image_ptr cub_buff);
unsigned char cubic_interpolation(unsigned char image[4][4], float x, float y, double a);
image_ptr extra_buffer_make(char *filename, int xextra, int yextra);
extern int getnum(FILE *fp);
image_ptr copy_buffer(image_ptr buffer,image_ptr cub_buf, int rows, int cols);

int main(int argc, char *argv[]){
char filein[100];
char fileout[100];
int rows, cols;
image_ptr buffer, cub_buf, cub_buffer;
int type;
//스케일 바꿔주는 부분.
float x_scale=0.5;
float y_scale=0.5;

if(argc == 3){
strcpy(filein, argv[1]);
strcpy(fileout, argv[2]);
}else{
printf("Input name of input file\n");
gets(filein);
printf("\nInput name of output file\n");
gets(fileout);
printf("\n");
}

buffer = read_pnm(filein, &rows, &cols, &type);
//원본영상의 버퍼 (+ 여분의 버퍼)를 할당해 줍니다.
cub_buf = extra_buffer_make(filein, 4, 4);
// 영상의 테두리 한줄씩을 바깥쪽으로 두줄씩 복사해줍니다.
cub_buffer = copy_buffer(buffer, cub_buf, rows, cols);
scale_pnm(buffer, fileout, rows, cols, x_scale, y_scale, type, cub_buffer);
IP_FREE(buffer);
IP_FREE(cub_buf);
return 0;
}


void scale_pnm(image_ptr buffer, char *fileout, int rows, int cols,
float x_scale, float y_scale, int type, image_ptr cub_buff){
unsigned long x,y;
unsigned long index;
unsigned char *line_buff;
int new_rows, new_cols;
unsigned line;
FILE *fp;
float X_Source, Y_Source;
unsigned char pixel;
unsigned char image[4][4];
double a = -0.5;
unsigned long intx_Source,inty_Source, cub_source;

if((fp=fopen(fileout, "wb")) == NULL){
printf("Unable to open %s for output\n",fileout);
exit(1);
}
new_cols = (int)(cols * x_scale);
new_rows = (int)(rows * y_scale);

fprintf(fp, "P%d\n%d %d\n255\n", type, new_cols, new_rows);

if(type == 5) line = new_cols;
line_buff = (unsigned char *) malloc(line);

for(y=0; y<new_rows; y++){
index = 0;
for(x=0; x<new_cols; x++){
X_Source = x / x_scale;
Y_Source = y / y_scale;
// 1.0스케일링의 simulation결과 X_Source - 0.5, Y_Source-0.5를 한 값을 int로 형변환해야 3차회선보간법을 거친 결과 영상이 제대로 나오는 것을 알았습니다.
intx_Source = (int)(X_Source - 0.5);
inty_Source = (int)(Y_Source - 0.5);
cub_source = inty_Source * (cols + 4) + intx_Source;
cub_source += 2*(cols + 4) + 2;
//3차회선 보간에 필요한 image배열값을 넣어줍니다.
//단순무식한 방법을 썼습니다. 직접넣기……
image[0][0] = cub_buff[cub_source-(cols+4)-1];
image[0][1] = cub_buff[cub_source-(cols+4)];
image[0][2] = cub_buff[cub_source-(cols+4)+1];
image[0][3] = cub_buff[cub_source-(cols+4)+2];

image[1][0] = cub_buff[cub_source-1];
image[1][1] = cub_buff[cub_source];
image[1][2] = cub_buff[cub_source+1];
image[1][3] = cub_buff[cub_source+2];

image[2][0] = cub_buff[cub_source+(cols+4)-1];
image[2][1] = cub_buff[cub_source+(cols+4)];
image[2][2] = cub_buff[cub_source+(cols+4)+1];
image[2][3] = cub_buff[cub_source+(cols+4)+2];

image[3][0] = cub_buff[cub_source+((cols+4)*2)-1];
image[3][1] = cub_buff[cub_source+((cols+4)*2)];
image[3][2] = cub_buff[cub_source+((cols+4)*2)+1];
image[3][3] = cub_buff[cub_source+((cols+4)*2)+2];
//3차회선보간함수를 호출합니다.
pixel = cubic_interpolation(image,1.0,1.0, a);
if(type == 5) /* PGM */
//3차회선보간함수의 결과값인 pixel을 line_buff에 넣습니다.
line_buff[index++] = pixel;
}
fwrite(line_buff, 1, line, fp);
}
IP_FREE(line_buff);
fclose(fp);
}
//******************************************************************
//3차회선 보간 함수
//******************************************************************
unsigned char cubic_interpolation(unsigned char image[4][4], float x, float y, double a){
double column[4];
double a0, a1, a2, a3;
double x_plus_1, y_plus_1;
double one_minus_x, one_minus_y;
double two_minus_x, two_minus_y;
int i;
double pixel;

if((x == 0.0) && (y == 0.0)){
return image[1][1];
}

if(x == 0.0)
for(i=0; i<4; i++) column[i] = (double) image[i][1];
else{
x_plus_1 = x + 1.0;
one_minus_x = 1.0 - x;
two_minus_x = 2.0 - x;

a0 = ((a * x_plus_1 - 5.0 * a) * x_plus_1 + 8.0 * a) * x_plus_1 - 4.0 * a;
a1 = ((a + 2.0) * x - (a + 3.0)) * x * x + 1;
a2 = ((a + 2.0) * one_minus_x - (a + 3.0)) * one_minus_x * one_minus_x + 1;
a3 = ((a * two_minus_x - 5.0 * a) * two_minus_x + 8.0 * a) * two_minus_x - 4.0 * a;

if(y == 0.0){
pixel = a0 * image[1][0] + a1 * image[1][1] + a2 * image[1][2] + a3 * image[1][3];
CLIP(pixel, 0.0, 255.0);
return (unsigned char) pixel;
}else
for(i=0; i<4; i++) column[i] = a0 * image[i][0] + a1 * image[i][1] + a2 * image[i][2] + a3 * image[i][3];
}

y_plus_1 = y + 1.0;
one_minus_y = 1.0 - y;
two_minus_y = 2.0 - y;

a0 = ((a * y_plus_1 - 5.0 * a) * y_plus_1 + 8.0 * a) * y_plus_1 - 4.0 * a;
a1 = ((a + 2.0) * y - (a + 3.0)) * y * y + 1;
a2 = ((a + 2.0) * one_minus_y - (a + 3.0)) * one_minus_y * one_minus_y + 1;
a3 = ((a * two_minus_y - 5.0 * a) * two_minus_y + 8.0 * a) * two_minus_y - 4.0 * a;

pixel = column[0] * a0 + column[1] * a1 + column[2] * a2 + column[3] * a3;
CLIP(pixel, 0.0, 255.0);
return (unsigned char) pixel;
}
//*********************************************************************
//3차회선 보간법을 하기 위해 원본영상의 둘레에 2줄씩 복사하기 위해 메모리를 할당하는 함수
//filename : 입력받은 원본 영상의 파일 이름
//xextra : rows의 복사할 갯수, 3차회선 보간법에서는 4, 왜냐하면 image배열이 4X4이기 때문에 양쪽으로 2줄씩만 복사하면 충분합니다.
//yextra : cols 의 복사할 개수, 3차회선 보간법에서는 4, 왜냐하면 image배열이 4X4이기 때문에 양쪽으로 2줄씩만 복사하면 충분합니다.
//*********************************************************************
image_ptr extra_buffer_make(char *filename, int xextra, int yextra){
int row_size;
int maxval;
int rows,cols,type;
FILE *fp;
int firstchar, secchar;
image_ptr ptr;
unsigned long total_size,cub_total_size;
float scale;
int add_rows, add_cols;

if((fp = fopen(filename, "rb")) == NULL)
{
printf("Unable to open %s for reading\n",filename);
exit(1);
}

firstchar = getc(fp);
secchar = getc(fp);

if(firstchar != 'P')
{
printf("You silly goof... This is not a PPM file!\n");
exit(1);
}

cols = getnum(fp);
rows = getnum(fp);
type = secchar - '0';

switch(secchar)
{
case '4': /* PBM */
scale = 0.125;
maxval = 1;
break;
case '5': /* PGM */
scale = 1.0;
maxval = getnum(fp);
break;
case '6': /* PPM */
scale = 3.0;
maxval = getnum(fp);
break;
default : /* Error */
printf("read_pnm: This is not a Portable bitmap RAWBITS file\n");
exit(1);
break;
}

row_size = (int)(cols * scale);
total_size = (unsigned long) rows * row_size;
add_rows=(int)((cols+xextra)*scale*yextra);
add_cols=(int)(xextra*scale*rows);
cub_total_size = (unsigned long)(total_size + add_rows + add_cols);
ptr = (image_ptr) IP_MALLOC(cub_total_size);

if(ptr == NULL)
{
printf("Unable to malloc %lu bytes\n",cub_total_size);
exit(1);
}

fclose(fp);
return ptr;
}
//****************************************************************
//영상의 테두리 한줄씩을 바깥쪽으로 두줄씩 복사하는 함수
//buff : 원본 영상 포인터
//cub_buff : 3차회선보간법에 쓸 영상 포인터
//rows : 원본 영상의 rows
//cols : 원본 영상의 cols
//****************************************************************
image_ptr copy_buffer(image_ptr buffer, image_ptr cub_buff, int rows, int cols){
unsigned char left[2];
unsigned char right[2];
unsigned char *copy;
unsigned long sourcebase, copyadd;
int x, y, i, k,h;
unsigned long j=0;
copy = (unsigned char *) malloc(cols);
for(y=0; y<rows; y++){
sourcebase = (unsigned long) cols * y;
copyadd=0;
//원본영상의 한 라인을 copy에 복사합니다.
for(x=0;x<cols;x++) copy[copyadd++] = buffer[sourcebase++];
//left,right배열에 첫픽셀과 마지막 픽셀을 두번 복사합니다.
for(i=0;i<2;i++) left[i]=copy[0];
for(i=0;i<2;i++) right[i]=copy[cols-1];
//y==0, 즉 첫라인일 때, 영상의 윗 두줄을 복사합니다.
if(y==0)
for(i=0;i<2;i++){
for(h=0;h<2;h++) cub_buff[j++] = left[h];
for(k=0;k<cols;k++) cub_buff[j++] = copy[k];
for(h=0;h<2;h++) cub_buff[j++] = right[h];
}
for(h=0;h<2;h++) cub_buff[j++] = left[h];
for(k=0;k<cols;k++) cub_buff[j++] = copy[k];
for(h=0;h<2;h++) cub_buff[j++] = right[h];
//y==rows-1, 즉 마지막라인일 때, 영상의 아래 두줄을 복사합니다.
if(y==(rows-1))
for(i=0;i<2;i++){
for(h=0;h<2;h++) cub_buff[j++] = left[h];
for(k=0;k<cols;k++) cub_buff[j++] = copy[k];
for(h=0;h<2;h++) cub_buff[j++] = right[h];
}
}
IP_FREE(copy);
return cub_buff;
}
 

3차 회선 보간법(cubic interpolation)을 이용한 시뮬레이션입니다.

 

